\documentclass{article}

\usepackage{enumitem}

\begin{document}

\section*{Übung 10 Lösung}

    \subsection*{Aufgabe 2}

    \begin{enumerate}[label=(\alph*)]

        \item Die Funktion uberpüft, ob das Produkt zweier Vektorelemente gleich der Summe aller Elemente ist:
		\newline\newline
		Die erste \textit{for-Schleife} addiert alle Elemente des Vektors, daher hat dieser Abschnitt eine Laufzeit von \textbf{n}.
		Als nächstes wird erneut  der Vektor durchlaufen, und dies zwei Mal (ersichtlich an den Iteratorvariablen \textit{i} und \textit{j}.
		Innerhalb dieser 2 Schleifen wird nun geschaut, ob das Produkt der zwei Einträge \textit{v[i]} und \textit{v[j]} gleich der in der vorherigen Schleife errrechneten
		Summe ist. Wurden diese 2 Einträge gefunden, so brechen die 2 Schleifen ab und die Funktion gibt \textit{true} zurück, andernfalls haben die zwei Schleifen
		eine Laufzeit von \textbf{n²}.

		Dieser Algorithmus terminiert also spätestens nach n²+n Schleifendurchäufen und hat damit eine Laufzeit von $n^{2}+n \in O(n^{2})$, jedoch 
		ist der Algorithmus nicht
		korrekt, da in den beiden Schleifen nicht geprüft wird, ob\newline \textit{v[i]} == \textit{v[j]}
		ist, sprich, ob ein Vektorelement mit sich selbst multipliziert wird.
	
		\item  Die Funktion addiert die Elemente an geraden (even) Index-Positionen in sum\_even\_odd[0] und
		die Elemente an ungeraden (odd) Index-Positionen in sum\_even\_odd[1]:
		\newline\newline
		Zu Beginn wird ein Vektor mit 2 Einträgen, welche mit 0 initialisiert werden, erstellt. Für die Bestimmung der Laufzeit ist dieser Befehl uninteressant.
		Als nächstes folgen 2 \textit{for-Schleifen}, wobei der Iterator \textbf{i} der äußeren Schleife die Werte 0 und 1 annimmt. In der inneren Schleife wird der Iterator \textbf{j}
		immer um 2 erhöht, was zur Folge hat, dass im 1. äußeren Schleifendurchlauf zunächst alle geraden Einträge durch v[i + j] (also v[ 0 + j]) addiert werden (i = 0) und im 2. 
		Durchlauf (i = 1) alle ungeraden Einträge (v[1 + j]) miteinander addiert werden.

		Der Algorithmus funktioniert gemäß seiner Beschreibung und hat eine Laufzeit (terminiert spätestens in) von $2 \cdot \frac{n}{2} \in O(n)$.

		\item Die Funktion hangt für jedes Element im Vektor die Zahl mit umgedrehten Vorzeichen an:
		\newline\newline
		Interessant an diesem Algorithmus ist, dass die Abbruchbedingung das Ende des Vektors ist, diese aber nicht vorher in einer seperaten Variable festgehalten wird, sondern sich
		nach jedem Schleifendurchlauf neu berechnet, was zur Folge hat, dass dieser Algorithmus nicht terminieren kann, da mit jedem Schleifenduchlauf der Vektor größer wird und das Ende
		nie erreicht werden kann.

		\item Die Funktion berechnet die Summe der Elemente an den Index-Positionen, die eine Zweierpotenz
		sind: $2^0, 2^1, 2^2, 2^3, ...$ (sofern dies ein gultiger Index, also kleiner als die Länge des Vektors ist)
		\newline\newline
		Weil die \textit{for-Schleife} lediglich Index-Positionen abruft, welche eine Zweierpotenz ist, terminiert der Algorithmus spätestens nach $0(\log_2(n))$ Schritten.
		Allerdings ist der Algorithmus fehlerhaft, da die Einträge von Vektoren mit 0 (v[0]) und nicht 1 (v[1]) beginnen. Zudem müsste i mit i = 1 initalisiert werden, um den $2^0$.ten Eintrag
		zu addieren; es müsste also \textit{sum += v[i - 1]} in der 8. Zeile stehen.

		\item  Die Funktion bestimmt die Menge aller Teilmengen der n Elemente im Vektor v (Beispiel: v=\{1,2,3\} $\Rightarrow$  \{ \{\},\{1\},\{2\},\{3\},\{1,2\},\{1,3\},\{2,3\},\{1,2,3\} \})
		\newline\newline
		Da die Potenzmenge $\mathcal{P}(v)$ gebildet wird, werden $(2^n) - 1$ Elemente erzeugt, was eine gleiche Laufzeit von $2^n \in O(2^n)$ zur Folge hat, was man bei der Betrachtung des Algorithmus
		nachvollziehen kann:\newline
		Zu Beginn wird die leere Menge zu \textit{subsets} hinzugefügt, was zur Folge hat, dass in der inneren \textit{for-Schleife} das 1. Element des Vektors \emph{v} als Teilmenge hinzugefügt wird.
		Im nächsten äußeren Schleifendurchlauf \newline( i = 1 ) ist die \emph{subset.size()} nun 2, d.h. die innere Schleife wird 2 mal durchlaufen, wobei die j-te Teilmenge durch 
		\emph{single\_set = subsets[j]} (also single\_set = \{\} im ersten Durchlauf und single\_set = \{1\}) in \emph{single\_set} geschrieben wird, bevor der \emph{i-te} Eintrag (2) in \emph{v}
		hinzugefügt und das \emph{single\_set} dem \emph{subsets} hinzugefügt wird.
		Für die nächsten Einträge läuft der Algorithmus analog.   

    \end{enumerate}

\end{document}